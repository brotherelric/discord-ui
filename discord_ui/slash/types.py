from __future__ import annotations


from ..tools import _or, _default, _none
from ..errors import InvalidLength, WrongType
from ..enums import CommandType, OptionType
from .http import SlashHTTP
from .errors import (
    CallbackMissingContextCommandParameters, 
    MissingOptionParameter, 
    NoAsyncCallback, 
    OptionalOptionParameter,
    NoCommandFound
)

import discord

import re
import typing
import inspect

__all__ = (
    'SlashOption',
    'SlashPermission',
)

def format_name(value):
    return str(value).lower().replace(" ", "-")

class SlashOptionCollection():
    def __init__(self, options=[]):
        self.__options = {x.name if isinstance(x, SlashOption) else x["name"]: SlashOption._from_data(x) if isinstance(x, dict) else x for x in options}
    
    def __repr__(self) -> str:
        return "<SlashOptionCollection[" + ', '.join([x.__repr__() for x in self]) + "]>"
    def __eq__(self, o):
        if isinstance(o, SlashOptionCollection):
            return len(self) == len(o) and self.__options == o.__options
        if isinstance(o, list):
            return len(o) == len(self.__options) and list(self.__options.values()) == o
        return False
    def __ne__(self, o) -> bool:
        return self.__eq__(o)
    def __len__(self):
        return len(self.__options)
    def __iter__(self):
        return iter(self.__options.values())
    def __getitem__(self, index):
        if isinstance(index, int):
            return list(self.__options.values())[index]
        elif isinstance(index, str):
            return self.__options[index]
        raise TypeError()
    def __setitem__(self, index, value):
        if isinstance(index, int):
            self.__options[list(self.__options.keys())[index]] = value
        elif isinstance(index, str):
            self.__options[index] = value
        else:
            raise WrongType("index", index, ["int", "str"])
    def __delitem__(self, index):
        if isinstance(index, int):
            del self.__options[list(self.__options.keys())[index]]
        elif isinstance(index, str):
            del self.__options[index]
        else:
            raise WrongType("index", index, ["int", "str"])
    def __add__(self, value):
        if isinstance(value, list):
            if all(isinstance(x, SlashOption) for x in value):
                copy = self.copy()
                for x in value:
                   copy.set(x.name, x)
                return copy
            elif all(isinstance(x, dict) for x in value):
                copy = self.copy()
                for x in value:
                   copy.set(x["name"], SlashOption._from_data(x))
                return copy
            else:
                for i, x in enumerate(value):
                    if not isinstance(value, (dict, SlashOption)):
                        raise WrongType(f"value[{i}]", x, ["list", "SlashOption", "dict"])
        if isinstance(value, SlashOption):
            return self.copy().set(value.name, value)
        elif isinstance(value, dict):
            return self.copy().set(value["name"], SlashOption._from_data(value))
        else:
            raise WrongType("value", value, ["list", "SlashOption", "dict"])
    
    def append(self, value):
        self.__options[value.name] = value
    def copy(self):
        return SlashOptionCollection(list(self.__options.values()))
    def get(self, index: typing.Union[str, int], default=None):
        try:
            return self.__getitem__(index)
        except (IndexError, KeyError):
            return default
    def set(self, index, value):
        self.__setitem__(index, value)
        return self
    def to_dict(self):
        return [x.to_dict() for x in self]

class SlashOption():
    """An option for a slash command
        
    Parameters
    ----------
    argument_type: :class:`int` | :class:`str` | :class:`class` | :class:`~OptionType`
        What type of parameter the option should accept.
    name: :class:`str`
        1-32 lowercase character name for the option.
    description: :class:`str`, optional
        1-100 character description of the command; default `\u200b`
    required: :class:`bool`, optional
        If the parameter is required or optional; default False
    choices: List[:class:`dict`], optional
        Choices for string and int types for the user to pick from; default None
            Choices should be formated like this: ``[{"name": "name of the choice", "value": "the real value"}, ...]``

            .. note::

                The choice value has to be of the same type as the type this option accepts.
    
    autocomplete: :class:`bool`, optional
        Whether the choices should be autogenerated; default None
    choice_generator: :class:`function`, optional
        A function that generates the choices for this option. Needds to return a list of dicts or tuples; default None
            This will automatically set autocomplete to True if autocomplete was not passed.
    options: List[:class:`~SlashOption`]
        This parameter is only for subcommands to work, you shouldn't need to use that, unless you know what you're doing.
    channel_types: List[:class:`discord.ChannelType`]
        If the option is a channel type, the channels shown will be restricted to these types.
    """
    def __init__(self, argument_type, name, description=None, required=False, choices=None, 
        autocomplete=None, choice_generator=None, options=None, channel_types=None
    ) -> None:
        """
        Creates a new option for a slash command

        Example
        ```py
        SlashOption(argument_type=int, name="Your number", required=True, choices=[{"name": "a cool number", "value": 2}])
        ```
        """
        autocomplete = autocomplete or choice_generator is not None

        self.__choice_generators__ = {}

        self._options: SlashOptionCollection = None # set later
        self._json = {}
        self.argument_type = argument_type
        self.name = name
        self.description = _or(description, "\u200b")
        self.required = required
        self.options = options or []
        self.autocomplete = autocomplete
        self.choices = choices if self.autocomplete is False else None
        self.choice_generator: typing.Callable[[typing.Any], typing.List[typing.Union[dict, tuple]]] = choice_generator
        """A function which will generate choices for this option"""
        self.channel_types = channel_types
    def __repr__(self) -> str:
        return f"<discord_ui.SlashOption({str(self.to_dict())})>"
    def __eq__(self, o: object) -> bool:
        if isinstance(o, SlashOption):
            return (
                self.argument_type == o.argument_type 
                    and 
                self.name == o.name 
                    and 
                self.description == o.description 
                    and 
                self.required == o.required 
                    and 
                self.choices == o.choices 
                    and 
                self.options == o.options
                    and
                self.channel_types == o.channel_types
            )
        elif isinstance(o, dict):
            return (
                self.argument_type == o["type"] 
                    and 
                self.name == o["name"] 
                    and 
                self.description == o.get("description") 
                    and 
                self.required == o.get("required", False)
                    and 
                (self.choices == o.get("choices", []) or self.choices == o.get("choices", None))
                    and 
                (self.options == o.get("options", []) or self.options == o.get("options", None))
                    and
                self.autocomplete == o.get("autocomplete", False)
                    and
                sorted([x.value for x in self.channel_types]) == sorted(o.get("channel_types", []))
            )
        return False
    def __ne__(self, o: object) -> bool:
        return not self.__eq__(o)

    def autocomplete_function(self, callback):
        """Decorator for the autocomplete choice generator
        
        Usage
        ------

        .. code-block::

            op = SlashOption(...)
            
            @op.autocomplete_function
            async def generator(ctx):
                ... 
        """
        self.choice_generator = callback
        return callback

    @property
    def argument_type(self) -> int:
        """Parameter type that the option accepts
        
        :type: :class:`int`
        """
        return OptionType(self._json["type"])
    @argument_type.setter
    def argument_type(self, value: OptionType):
        self._json["type"] = getattr(value, "value", OptionType.any_to_type(value))

    @property
    def channel_types(self):
        """A list of channel types that will restrict the shown channels for this option
        
        :type: List[:class:`discord.ChannelType`]
        """
        return [discord.ChannelType(x) for x in self._json.get("channel_types", [])]
    @channel_types.setter
    def channel_types(self, value):
        self._json["channel_types"] = [getattr(x, "value", x) for x in (value or [])]

    @property
    def name(self) -> str:
        """The name of the option appearing in discord
        
        :type: :class:`str`
        """
        return self._json["name"]
    @name.setter
    def name(self, value):
        if not isinstance(value, str):
            raise WrongType("name", value, "str")
        if len(value) > 32 or len(value) < 1:
            raise InvalidLength("name", 1, 32)
        self._json["name"] = value.lower().replace(" ", "_")

    @property
    def description(self) -> str:
        """The description of the option appearing under the name
        
        :type: :class:`str`
        """
        return self._json["description"]
    @description.setter
    def description(self, value):
        if len(value) > 100 or len(value) < 1:
            raise InvalidLength("description", 1, 100)
        self._json["description"] = value

    @property
    def required(self) -> bool:
        """Whether this parameter is required to use or not

        :type: :class:`bool`
        """
        return self._json.get("required", False)
    @required.setter
    def required(self, value):
        if not isinstance(value, bool):
            raise WrongType("required", value, "bool") 
        self._json["required"] = value

    @property
    def choices(self) -> typing.List[dict]:
        """Choices for string and int types for the user to pick from
        
        .. note::
    
            Choices are formated like this: ``[{"name": "name of the choice", "value": "the real value"}, ...]``
    
        :type: List[:class:`dict`]
        """
        return self._json.get("choices")
    @choices.setter
    def choices(self, value):
        if isinstance(value, list):
            if all(isinstance(x, dict) for x in value):
                self._json["choices"] = value
            elif all(isinstance(x, tuple) for x in value):
                self._json["choices"] = [{"name": x[0], "value": x[1]} for x in value]
            else:
                raise WrongType("choices", value, ["List[dict]", "List[tuple]"])

    @property
    def options(self) -> SlashOptionCollection:
        """The parameters for the command.
    
        You can use the option's name (``.options["option name"]``) or the index of the option (``.options[index]``) to get an element.

        :type: :class:`SlashOptionCollection`
        """
        return self._options
    @options.setter
    def options(self, options):
        if not isinstance(options, list) and not isinstance(options, SlashOptionCollection):
            raise WrongType("options", options, ["list", "SlashOptionCollection"])
        if all(isinstance(x, (SlashOption, dict)) for x in options):
            self._options = (
                SlashOptionCollection([(x.to_dict() if type(x) is SlashOption else x) for x in options]) 
                    if not isinstance(options, SlashOptionCollection) else 
                options
            )
        else:
            for i, x in enumerate(options):
                if not isinstance(x, SlashOption) and not isinstance(x, dict):
                    raise WrongType("options[" + str(i) + "]", x, ["dict", "SlashOption"])
        # set autocomplete generators
        self.__choice_generators__ = {
            x.name: x.choice_generator or self.__choice_generators__.get(x.name) for x in 
                [SlashOption._from_data(o) if isinstance(o, dict) else o for o in options]
            }
        
    @property
    def autocomplete(self) -> bool:
        """Whether the choices for this option should be autocompleted
        
        :type: :class:`bool`
        """
        return self._json.get("autocomplete", False)
    @autocomplete.setter
    def autocomplete(self, value):
        self._json["autocomplete"] = value

    @property
    def focused(self) -> bool:
        return self._json.get("focused", False)
    
    @staticmethod
    def _from_data(data: dict, generator=None):
        return SlashOption(data["type"], data["name"], data["description"], data.get("required", False), data.get("choices"), data.get("autocomplete", False), generator, data.get("options"), data.get("channel_types", []))

    def to_dict(self):
        return self._json | {"options": self._options.to_dict()}

class AdditionalType:
    MESSAGE     =       44
    GUILD       =       45

class SlashPermission():
    """Permissions for a slash commannd
        
        Parameters
        ----------
        allowed: :class:`dict` | List[:class:`discord.Member` | :class:`discord.User` | :class:`discord.Role`], optional
            A list of ids, users or members that can use the command; default None
                Format: ``{"role_or_user_id": permission_type}]``


        forbidden: :class:`dict` | List[:class:`discord.Member` | :class:`discord.User` | :class:`discord.Role`], optional
            A list of ids, users or members that are forbidden to use the command; default None
    

        .. note::

            If you want to use a role id, the permission type has to be 1, and if you want to specify a user id, it has to be 2

            You can use ``SlashPermission.ROLE`` and ``SlashPermission.USER`` instead

        """
    def __init__(self, allowed: dict=None, forbidden=None) -> None:
        """Creates a new permission object for a slash command
        
        Example
        ```py
        SlashPermission(allowed=[
                await bot.fetch_user(bot.owner_id)
            ], forbidden={
                539459006847255232: SlashPermission.User,
                874357255829606402: SlashPermission.Role
            }
        )
        ```
        """
        
        self._json = []
        if allowed is not None:
            if isinstance(allowed, dict):
                for _id, _type in allowed.items():
                    self._json.append(
                        {
                            "id": int(_id),
                            "type": _type,
                            "permission": True
                        }
                    )
            elif isinstance(allowed, list):
                for t in allowed:
                    self._json.append({
                        "id": t.id,
                        "type": SlashPermission.USER if isinstance(t, (discord.User, discord.Member)) else SlashPermission.ROLE,
                        "permission": True
                    })
        if forbidden is not None:
            if isinstance(forbidden, dict):
                for _id, _type in forbidden.items():
                    self._json.append(
                        {
                            "id": int(_id),
                            "type": _type,
                            "permission": False
                        }
                    )
            elif isinstance(forbidden, list):
                for t in forbidden:
                    self._json.append({
                        "id": t.id,
                        "type": SlashPermission.USER if type(t) in [discord.User, discord.Member] else SlashPermission.ROLE,
                        "permission": False
                    })
            else:
                raise WrongType("forbidden", forbidden, ["Dict[int | str, int]", "List[discord.Member | discord.User | discord.Role]"])

    @classmethod
    def Empty(cls) -> SlashPermission:
        """Returns an empty permission for the command"""
        return cls()
    def to_dict(self):
        return self._json
    def __eq__(self, o: object) -> bool:
        if isinstance(o, SlashPermission):
            return (
                len(self.allowed) == len(o.allowed) and all(self.allowed[i] == o.allowed[i] for i, _ in enumerate(o.allowed)) and
                len(self.forbidden) == len(o.forbidden) and all(self.forbidden[i] == o.forbidden for i, _ in enumerate(o.forbidden))
            )
        elif isinstance(o, dict):
            o_allowed = [x for x in o["permissions"] if x["permission"] == True]
            o_forbidden = [x for x in o["permissions"] if x["permission"] == False]

            return (
                len(self.allowed) == len(o_allowed) and all(self.allowed[i] == o_allowed[i] for i, _ in enumerate(self.allowed)) and
                len(self.forbidden) == len(o_forbidden) and all(self.forbidden[i] == o_forbidden[i] for i, _ in enumerate(self.forbidden))
            )
        return False
    def __ne__(self, o: object) -> bool:
        return not self.__eq__(o)
    def __repr__(self) -> str:
        return f"<discord_ui.SlashPermission({self.to_dict()})>"
    
    @staticmethod
    def _from_data(data):
        perm = SlashPermission()
        perm._json = data
        return perm


    ROLE        =       Role      =   1
    USER        =       User      =   2

    @property
    def allowed(self) -> dict:
        return [x for x in self._json if x["permission"] == True]
    @property
    def forbidden(self) -> dict:
        return [x for x in self._json if x["permission"] == False]


class BaseCommand():
    __slots__ = ('__aliases__', '__sync__', '__auto_defer__', '__guild_changes__', '__original_name__', 
        '__choice_generators__', '_http', '_id', '_options', '_json', 'callback', 'guild_ids',
        'guild_permissions', 'permissions', 'run'
    )
    def __init__(self, command_type, callback, name=None, description=None, options=None, guild_ids=None, default_permission=None, guild_permissions=None, http=None) -> None:
        self.__aliases__ = getattr(callback, "__aliases__", None)
        self.__sync__ = getattr(callback, "__sync__", True)
        self.__auto_defer__ = getattr(callback, "__auto_defer__", None)
        self.__guild_changes__ = getattr(callback, "__guild_changes__", {})
        self.__choice_generators__ = {}
        self._http: SlashHTTP = http
        self._id: int = None # set later

        self._options: SlashOptionCollection = SlashOptionCollection([]) # set later
        self._json = {"type": getattr(command_type, "value", command_type)}

        self.options = _default([], options)
        if callback is not None:
            if not inspect.iscoroutinefunction(callback):
                raise NoAsyncCallback()

            _params = inspect.signature(callback).parameters
            keys = list(_params.keys())
            callback_params = {
                x: _params[x] for i, x in enumerate(_params)
                    if i > (0 if keys[0] != "self" else 1)
            }
            has_kwargs = 4 in [x.kind for x in list(callback_params.values())]
            if self.options is not None:
                for op in self.options:
                    if callback_params.get(op.name) is None and has_kwargs:
                        continue
                    if callback_params.get(op.name) is None:
                        raise MissingOptionParameter(op.name)
                    param = callback_params[op.name]
                    if not op.required and param.default is param.empty:
                        raise OptionalOptionParameter(param.name)
            # if no options provided via options=[], check callback params instead
            if options == None and self.command_type is CommandType.Slash:
                _ops = []
                
                style = 0
                results = []
                doc = '\n'.join(inspect.getdoc(callback).split('\n')[1:]).removeprefix("\n") if inspect.getdoc(callback) != None else ""
                # check docstring pattern
                # style 1
                #
                #       Slashcommand description
                #       param1: `type`:
                #           description here
                #       param2: `type`:
                #           description here
                if len(re.findall(r'\w+: `?\w+`?:?\n.*', doc)) > 0:
                    results = re.findall(r'\w+: `?\w+`?:?\n.*', doc)
                    style = 1
                # style 2
                #
                #       Slashcommand description
                #       param1: description here
                #       param2: description here
                elif len(re.findall(r'\w+:\W.*', doc)) > 0:
                    results = re.findall(r'\w+:\W.*', doc)
                    style = 2
                # style 3
                #
                #       Slashcommand description
                #       param1 description
                #       param2 description
                elif len(doc.split("\n")) > 0:
                    results = doc.split("\n")
                    style = 3

                for _i, _name in enumerate(callback_params):
                    _val = callback_params.get(_name)
                    op_type = None
                    op_desc = None
                    if _val.annotation != _val.empty:
                        op_type = _val.annotation
                    elif _val.default != inspect._empty:
                        op_type = type(_val.default)
                    else: 
                        op_type = _name

                    if style != 0 and _i < len(results):
                        if style == 1:
                            res = results[_i]
                            _name = res.split(":")[0]
                            _type = res.split(":")[1].split("\n")[0].removesuffix(":").removeprefix(" ").replace("`", "").removeprefix(":class:").removeprefix("~")
                            op_desc = re.split(r'\s\s+', res.split("\n")[1])[1]
                            if OptionType.any_to_type(op_type) is None:
                                op_type = _type
                        elif style == 2:
                            res = results[_i]
                            _name = res.split(":")[0]
                            op_desc = ": ".join(res.split(": ")[1:])
                        elif style == 3:
                            res = results[_i]
                            if ":" in res:
                                op_desc = ':'.join(res.split(":")[1:]).removeprefix(" ")
                                _type = res.split(":")[0].replace("`", "")
                                if OptionType.any_to_type(op_type) is None:
                                    op_type = _type
                        
                    if OptionType.any_to_type(op_type) is None:
                        raise discord.errors.InvalidArgument("Could not find a matching option type for parameter '" + str(op_type) + "'")
                    _ops.append(SlashOption(op_type, _name, op_desc, required=_val.default == inspect._empty))
                self.options = _ops

        self.callback: typing.Callable[..., typing.Coroutine[typing.Any, typing.Any, typing.Any]] = callback
        self.run = self.callback
        """Alias for ``.callback``"""
        self.name = _or(name, self.callback.__name__ if not _none(self.callback) else None)
        # Set the original name to the name once so if the name should be changed, this value still stays to what it is
        self.__original_name__ = self.name
        self.description = _or(description, inspect.getdoc(callback).split("\n")[0] if not _none(callback) and inspect.getdoc(callback) is not None else None, "\u200b")
        self.default_permission = default_permission if default_permission is not None else True
        if guild_permissions is not None:
            for _id, perm in list(guild_permissions.items()):
                if not isinstance(_id, (str, int, discord.User, discord.Member, discord.Role)):
                    raise WrongType("guild_permissions key " + str(_id), _id, ["str", "int", "discord.User", "discord.Member", "discord.Role"])
                if not isinstance(perm, SlashPermission):
                    raise WrongType("guild_permission[" + ("'" if isinstance(_id, str) else "") + str(_id) + ("'" if isinstance(_id, str) else "") + "]", perm, "SlashPermission")
        
        self.guild_permissions: typing.Dict[(typing.Union[str, int], SlashPermission)] = guild_permissions
        self.permissions: SlashPermission = SlashPermission()
        self.guild_ids: typing.List[int] = _default(None, [int(x) for x in _or(guild_ids, [])])
        """The ids of the guilds where the command is available"""
    def __repr__(self) -> str:
        return f"<{self.__class__.__name__.split('.')[-1]}({self.to_dict()})>"
    def __eq__(self, o: object) -> bool:
        if isinstance(o, dict):
            return (
                o.get('type') == self.command_type.value 
                and o.get('name') == self.name
                and o.get('description') == self.description
                and o.get('options', []) == self.options
                and o.get("default_permission", True) == self.default_permission
            )
        elif isinstance(o, SlashCommand):
            return (
                o._json('type') == self._json["type"]
                and o.name == self.name
                and o.description == self.description
                and o.options == self.options
                and o.default_permission == self.default_permission
            )
        else:
            return False
    def __ne__(self, o: object) -> bool:
        return not self.__eq__(o)
    async def __call__(self, ctx, *args, **kwargs):
        return await self.callback(ctx, *args, **kwargs)

    @property
    def subcommands(self) -> typing.List[SlashSubcommand]:
        subs = []
        for x in self.options:
            if x.argument_type == OptionType.SUB_COMMAND:
                subs.append(SlashSubcommand(None, self.name, x.name, x.description, x.options, self.guild_ids, self.default_permission, self.guild_permissions, self._http))
            if x.argument_type == OptionType.SUB_COMMAND_GROUP:
                for y in x.options:
                    if x.argument_type == OptionType.SUB_COMMAND:
                        subs.append(SlashSubcommand(None, [self.name, x.name], y.name, x.description, x.options, self.guild_ids, self.default_permission, self.guild_permissions, self._http))
        return subs
    @property
    def guild_only(self) -> bool:
        """Whether this command is limited to some guilds ``True`` or global ``False``"""
        return self.guild_ids != None and len(self.guild_ids) > 0
    @property
    def is_message_context(self) -> bool:
        """Wether is command is a message-context command"""
        return self.command_type is CommandType.Message
    @property
    def is_user_context(self) -> bool:
        """Whether this command is a user-context command"""
        return self.command_type is CommandType.User
    @property
    def is_chat_input(self) -> bool:
        """Whether this command is a chat-input command"""
        return self.command_type is CommandType.Slash
    @property
    def is_slash_command(self) -> bool:
        """
        Whether this command is a slashcommand
            Same as `.is_chat_input`
        """
        return self.is_chat_input
    @property
    def is_subcommand(self) -> bool:
        """
        Whether this command is a subcommand
        """
        return self.is_chat_input and hasattr(self, "base_names")

    @property
    def original_name(self) -> str:
        """The original name for this command"""
        return self.__original_name__
    @property
    def aliases(self) -> typing.List[str]:
        """The list of available aliases for this command"""
        return self.__aliases__
    @property
    def has_aliases(self) -> bool:
        """Returns True if this command has aliases"""
        return hasattr(self, "__aliases__") and self.__aliases__ is not None
    @property
    def is_alias(self) -> bool:
        """Returns True if this command is an alias to another command"""
        return self.__aliases__ is not None and self.name in self.__aliases__

    # region command
    @property
    def command_type(self) -> CommandType:
        return CommandType(self._json["type"])

    @property
    def name(self) -> str:
        """The name of the slash command
        
        :type: :class:`str`
        """
        return self._json["name"]
    @name.setter
    def name(self, value):
        if _none(value):
            raise discord.errors.InvalidArgument("You have to specify a name")
        if not isinstance(value, str):
            raise WrongType("name", value, "str")
        if len(value) > 32 or len(value) < 1:
            raise InvalidLength("name", 1, 32)
        if self.command_type is CommandType.Slash:
            self._json["name"] = format_name(value)
        else:
            self._json["name"] = value
    @property
    def description(self) -> str:
        """The description of the command
        
        :type: :class:`str`
        """
        return self._json['description']
    @description.setter
    def description(self, value):
        if not isinstance(value, str):
            raise WrongType("description", value, "str")
        if len(value) > 100 or len(value) < 1:
            raise InvalidLength("description", 1, 100)
        self._json["description"] = value
    @property
    def options(self) -> SlashOptionCollection:
        """The parameters for the command.
    
        You can use the option's name (``.options["option name"]``) or the index of the option (``.options[index]``) to get an element.

        :type: :class:`SlashOptionCollection`
        """
        return self._options
    @options.setter
    def options(self, options):
        if not isinstance(options, list) and not isinstance(options, SlashOptionCollection):
            raise WrongType("options", options, ["list", "SlashOptionCollection"])
        if all(isinstance(x, (SlashOption, dict)) for x in options):
            self._options = (
                SlashOptionCollection([(x.to_dict() if type(x) is SlashOption else x) for x in options]) 
                    if not isinstance(options, SlashOptionCollection) else 
                options
            )
        else:
            for i, x in enumerate(options):
                if not isinstance(x, SlashOption) and not isinstance(x, dict):
                    raise WrongType("options[" + str(i) + "]", x, ["dict", "SlashOption"])
        # set autocomplete generators
        self.__choice_generators__ = {
            x.name: x.choice_generator or self.__choice_generators__.get(x.name) for x in 
                [SlashOption._from_data(o) if isinstance(o, dict) else o for o in options]
        }
    # endregion
    # region permissions
    @property
    def default_permission(self) -> typing.Union[str, bool]:
        """Default permissions that a user needs to have in order to execute this command
            If a bool was used, it will indicate whether this command can be used by everyone
        
        :type: :class:`str` | :class:`bool`
        """
        raw = self._json.get("default_permission", False)
        if isinstance(raw, str):
            return discord.Permissions(int(raw))
        return raw
    @default_permission.setter
    def default_permission(self, value):
        self._json["default_permission"] = str(value.value) if isinstance(value, discord.Permissions) else value
    # endregion

    @property
    def command_id(self) -> int:
        """The ID of the command.

        The ID is None until the command was synced with `.sync_commands`

        :type: :class:`int`
        """
        return self._id
    async def update(self, guild_id=None):
        """Updates the api-command with the local changes
        
        guild_id: :class:`int`, optional:
            The guild id to which the command update should be limited
        """
        if self.guild_only:
            [await self._http.edit_guild_command(self._id, guild, self.to_dict(), self.permissions.to_dict()) for guild in ([guild_id] if guild_id else self.guild_ids)]
        else:
            await self._http.edit_global_command(self._id, self.to_dict())
    async def edit(self, **fields):
        """Edits this slashcommand and updates the changes in the api

        Parameters
        ----------
        ``fields``: :class:`**dict`:
            The fields you want to edit (ex: ``name="new name"``)
        """

        for x in fields:
            setattr(self, x, fields[x])
        return await self.update_apicommand()
    async def delete(self, guild_id=None):
        """Deletes this command from the api
        
        Parameters
        ----------
        guild_id: :class:`int`, optional
            A guild id where the command should be deleted from. If passed, the command will only be deleted from this guild; default ``None``
        
        """
        if self.guild_only:
            if guild_id:
                await self._http.delete_guild_command(self.command_id, guild_id)
            else:
                [await self._http.delete_guild_command(self.command_id, guild) for guild in self.guild_ids]
        else:
            await self._http.slash_http.delete_global_command(self.id)
    
    async def _fetch_id(self):
        try:
            return int(await self._http.get_id(getattr(self, 'base_names', [self.name,])[0], self.guild_ids[0] if self.guild_only else None, self.command_type))
        except NoCommandFound:
            return None
    async def _update_id(self, _http=None):
        if _http is not None:
            self._http = _http
        self._id = await self._fetch_id()
        return self._id
    def _patch(self, command):
        self.__aliases__ = command.__aliases__
        self.guild_permissions = command.guild_permissions

    def copy(self):
        """Copies itself into a new object"""
        raise NotImplementedError()

    def to_dict(self):
        return self._json | {"options": self._options.to_dict()}

class SlashCommand(BaseCommand):
    """A basic slash command
        
    Parameters
    ----------
    callback: :class:`function`
        The callback function
    name: :class:`str`
        1-32 characters long name
            If name is not passed, the name of the callback function will be used; default None
            
        .. important::

            The name will be corrected automaticaly (spaces will be replaced with "-" and the name will be lowercased)

    description: :class:`str`, optional
        1-100 character description of the command; default None
            If description is not passed, the docstring description of the callback function is used. 
            If no docstring exists, the name of the command will be used
    options: List[:class:`~SlashOptions`], optional
        Parameters for the command; default None
    choices: List[:class:`tuple`] | List[:class:`dict`], optional
        Choices for string and int types for the user to pick from; default None
    guild_ids: :class:`str` | :class:`int`, optional
        A list of guild ids where the command is available; default None
    default_permission: :class:`bool` | :class:`discord.Permissions`, optional
        Permissions that a user needs to have in order to execute the command, default ``True``. 
            If a bool was passed, it will indicate whether all users can use the command (``True``) or not (``False``)
    guild_permissions: Dict[``guild_id``: :class:`~SlashPermission`]
        The permissions for the command in guilds
            Format: ``{"guild_id": SlashPermission}``
    """
    def __init__(self, callback, name=None, description=None, options=None, guild_ids=None, default_permission=None, guild_permissions=None, http=None) -> None:
        """
        Creates a new base slash command
        
        Example

        ```py
        async def my_function(command, parameter=None):
            pass

        SlashCommand(callback=my_function, name="hello_world", description="This is a test command",
            options=[
                SlashOption(str, name="parameter", description="this is a parameter", choices=[("choice 1", 1)])
            ], guild_ids=[785567635802816595], default_permission=False,
            guild_permissions={
                785567635802816595: SlashPermission(allowed={"539459006847254542": SlashPermission.USER})
            })
        ```
        """
        BaseCommand.__init__(self, CommandType.Slash, callback, name, description, options, guild_ids, default_permission, guild_permissions, http)
    def copy(self) -> SlashCommand:
        c = SlashCommand(self.callback, self.name, self.description, self.options, self.guild_ids, self.default_permission, self.guild_permissions, self._http)
        for x in self.__slots__:
            setattr(c, x, getattr(self, x))
        return c

    @staticmethod
    def _from_data(data, permissions=None, slash_http=None, target_guild=None, guild_ids=None):
        return SlashCommand(None, data["name"], data["description"], data.get("options"), guild_ids, 
            data.get("default_permission", True), {target_guild: SlashPermission._from_data(permissions)} if permissions else None, slash_http
        )
    @staticmethod
    async def _from_api(id, slash_http, guild_id=None, guild_ids=None) -> SlashCommand:
        api = await slash_http.fetch_command(id, guild_id)
        permissions = None
        if guild_id:
            permissions = await slash_http.get_command_permissions(id, guild_id)
        return SlashCommand._from_data(api, permissions, slash_http, guild_id, guild_ids)
   
class SlashSubcommand(BaseCommand):
    __slots__ = BaseCommand.__slots__ + ('base_names', '_base')

    def __init__(self, callback, base_names, name, description=None, options=None, guild_ids=None, default_permission=None, guild_permissions=None, http=None) -> None:
        if isinstance(base_names, str):
            base_names = [base_names]
        if len(base_names) > 2:
            raise discord.errors.InvalidArgument("subcommand groups are currently limited to 2 bases")
        if any([len(x) > 32 or len(x) < 1 for x in base_names]):
            raise InvalidLength("base_names", 1, 32)
        BaseCommand.__init__(
            self, CommandType.Slash, callback, name, description, options=options, 
            guild_ids=guild_ids, default_permission=default_permission, guild_permissions=guild_permissions,
            http=http
        )
        self.base_names = [format_name(x) for x in base_names]
        self._base = None # a base instance shared with all subcommands
    async def fetch_base(self, guild_id=None, overwrite_base=True) -> SlashCommand:
        """Fetches the base command from the api
        
        `guild_id`: :class:`int`, optional
            The guild from which the base should be fetched
        `overwrite_base`: :class:`bool`, optional
            Whether `self.base` should be updated to the newly fetched base
        """
        command: SlashCommand = await SlashCommand._from_api(
            self._id, self._http, guild_id or self.guild_ids[0] if self.guild_only else None, 
            guild_ids=self.guild_ids
        )
        command.guild_permissions = self.guild_permissions
        if overwrite_base:
            self._base = command
        return command
    @property
    def base(self) -> SlashCommand:
        """A shared :class:`~SlashCommand` instance for all subcommands which holds information about the base command"""
        return self._base
    async def update(self):
        for guild in self.guild_ids:
            base = self.base or await self.fetch_base(guild)
            if len(self.base_names) > 1:
                if base.options.get(self.base_names[1]) is None:
                    base.options[self.base_names[1]] = SlashOption(OptionType.SUB_COMMAND_GROUP, self.name)
                base.options[self.base_names[1]].options[self.name] = self.to_option()
            else:
                base.options[self.name] = self.to_option()
            await base._update_id(self._http)
            return await base.update_apicommand(guild)
    def to_option(self) -> SlashOption:
        return SlashOption(OptionType.SUB_COMMAND, self.name, self.description, options=self.options or None, required=False)
    def to_dict(self):
        return self.to_option().to_dict()
    def copy(self):
        c = SlashSubcommand(self.callback, self.base_names, self.name, self.description, self.options, self.guild_ids, self.default_permission, self.guild_permissions, self._http)
        for x in self.__slots__:
            setattr(c, x, getattr(self, x))
        return c

class ContextCommand(BaseCommand):
    def __init__(self, context_type, callback, name=None, guild_ids=None, default_permission=True, guild_permissions=None, http=None) -> None:
        if callback is not None:
            callback_params = inspect.signature(callback).parameters
            if len(callback_params) < 2:
                raise CallbackMissingContextCommandParameters()
        BaseCommand.__init__(self, context_type, callback, name=name, guild_ids=guild_ids, default_permission=default_permission, guild_permissions=guild_permissions, http=http)

    @property
    def description(self) -> str:
        return ""
    @description.setter
    def description(self, value):
        pass
    @property
    def options(self) -> list:
        return self._options
    @options.setter
    def options(self, value):
        pass

class UserCommand(ContextCommand):
    def __init__(self, callback, name=None, guild_ids=None, default_permission=True, guild_permissions=None, http=None) -> None:
        ContextCommand.__init__(self, CommandType.User, callback, name, guild_ids, default_permission, guild_permissions, http)
    def copy(self) -> UserCommand:
        c = UserCommand(self.callback, self.name, self.guild_ids, self.default_permission, self.guild_permissions, self._http)
        for x in self.__slots__:
            setattr(c, x, getattr(self, x))
        return c

class MessageCommand(ContextCommand):
    def __init__(self, callback, name=None, guild_ids=None, default_permission=True, guild_permissions=None, http=None) -> None:
        ContextCommand.__init__(self, CommandType.Message, callback, name, guild_ids, default_permission, guild_permissions, http)
    def copy(self) -> MessageCommand:
        c = MessageCommand(self.callback, self.name, self.guild_ids, self.default_permission, self.guild_permissions, self._http)
        for x in self.__slots__:
            setattr(c, x, getattr(self, x))
        return c
